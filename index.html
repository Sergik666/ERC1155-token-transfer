<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ERC-1155 Балансы и Перевод (Polygon)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <!--script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js" integrity="sha512-FDcVY+g7vcNsW_IKoS3G+0hVcUO1XqAfdXTeQ66RbtB9MXNEufT1ZoXQMu5ZdG6pCLzWNdQuldGyMPLqSD779g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script-->
    <style>
        /* ... (остальные стили без изменений) ... */
        body { font-family: sans-serif; padding: 20px; background-color: #f4f4f4; }
        .container { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); max-width: 800px; margin: auto; }
        label { display: block; margin-top: 10px; font-weight: bold; }
        input[type="text"], input[type="number"] { width: calc(100% - 22px); padding: 10px; margin-top: 5px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; }
        button { background-color: #007bff; color: white; padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; margin-top: 15px; font-size: 16px; }
        button:disabled { background-color: #cccccc; cursor: not-allowed; }
        button:hover:not(:disabled) { background-color: #0056b3; }
        #status, #walletAddress, #balances, #transferStatus, #log { margin-top: 15px; padding: 10px; background-color: #e9ecef; border-radius: 4px; word-wrap: break-word; }
        #balances ul { list-style: none; padding: 0; }
        #balances li { display: flex; align-items: center; margin-bottom: 10px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; gap: 15px; flex-wrap: wrap; }
        .token-image { flex-basis: 60px; flex-shrink: 0; height: 60px; display: flex; align-items: center; justify-content: center; background-color: #f0f0f0; border-radius: 4px; overflow: hidden; font-size: 11px; color: #6c757d; text-align: center; }
        .token-image img { max-width: 100%; max-height: 100%; display: block; object-fit: contain; }
        .token-info { flex-grow: 1; text-align: left; min-width: 150px; }
        .token-info strong { display: block; margin-bottom: 3px; font-size: 1.1em; } /* Чуть крупнее имя */
        .token-info .balance-line { margin-top: 5px; } /* Отступ для строки баланса */
        .token-info .raw-balance-line {
             font-size: 0.85em; /* Мельче шрифт для raw */
             color: #6c757d;
             margin-top: 3px;
        }
        .token-info small { color: #6c757d; } /* ID */
        .token-info .metadata-error { color: #dc3545; font-size: 0.8em; display: block; margin-top: 3px; }
        .token-transfer { flex-basis: 120px; /* Немного шире инпут */ flex-shrink: 0; }
        .token-transfer input { width: 100%; padding: 8px; margin-top: 0; }
        #log { max-height: 200px; overflow-y: auto; }
        pre { background-color: #333; color: #fff; padding: 10px; border-radius: 4px; overflow-x: auto; white-space: pre-wrap; word-break: break-all; }
    </style>
</head>
<body>

<div class="container">
    <h1>ERC-1155 Инструмент (Polygon)</h1>
    <button id="connectButton">Подключить MetaMask</button>
    <div id="status">Статус: Не подключен</div>
    <div id="walletAddress">Адрес кошелька: -</div>

    <hr style="margin: 20px 0;">

    <label for="contractAddress">Адрес контракта ERC-1155 (Polygon):</label>
    <input type="text" id="contractAddress" placeholder="0x...">

    <button id="getBalanceButton" disabled>Получить балансы и метаданные</button>

    <h2>Балансы токенов (ID 0-50 с балансом > 0):</h2>
    <div id="balances">Нет данных</div>

    <hr style="margin: 20px 0;">

    <h2>Перевод токенов</h2>
    <label for="recipientAddress">Адрес получателя:</label>
    <input type="text" id="recipientAddress" placeholder="0x...">

    <div id="transferSection" style="margin-top: 10px;">
        <p>Укажите количество для перевода рядом с токеном выше.</p>
    </div>

    <button id="transferButton" disabled>Перевести выбранные токены (safeBatchTransferFrom)</button>
    <div id="transferStatus" style="margin-top: 10px;"></div>
     <div id="log">
        <h3>Лог:</h3>
        <pre id="logContent"></pre>
    </div>

</div>

<script>
    // --- Элементы DOM, Константы, ABI (без изменений) ---
    const connectButton = document.getElementById('connectButton');
    const getBalanceButton = document.getElementById('getBalanceButton');
    // ... остальные элементы
    const logContent = document.getElementById('logContent');

    const POLYGON_CHAIN_ID = '0x89';
    // ... остальные константы
    const METADATA_FETCH_TIMEOUT = 10000;

    let provider;
    let signer;
    let userAddress;
    let currentContractAddress;
    // ИЗМЕНЕНИЕ: Структура хранения данных о балансе
    let currentBalances = {}; // { idString: { rawBalance: string, decimals: number, name: string } }

    const erc1155Abi = [
        "function balanceOfBatch(address[] memory accounts, uint256[] memory ids) public view returns (uint256[] memory)",
        "function safeBatchTransferFrom(address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) public",
        "function uri(uint256 _id) public view returns (string memory)"
    ];

    // --- Функции логирования, подключения, переключения сети, хелперы URI (без изменений) ---
    function logMessage(message) { /* ... */
        console.log(message);
        const timestamp = new Date().toLocaleTimeString();
        logContent.textContent += `[${timestamp}] ${message}\n`;
        logContent.parentElement.scrollTop = logContent.parentElement.scrollHeight;
     }
    async function connectWallet() { /* ... */ }
    async function switchToPolygon() { /* ... */ }
    function handleAccountsChanged(accounts) { /* ... */ }
    function handleChainChanged(chainId) { /* ... */ }
    function resetApp() { /* ... */ }
     function resolveMetadataUri(uri, tokenId) { /* ... */
        if (!uri) return null;
         if (uri.includes('{id}')) {
            const hexId = ethers.BigNumber.from(tokenId).toHexString().substring(2).padStart(64, '0');
            uri = uri.replace('{id}', hexId);
        }
        if (uri.startsWith('ipfs://')) {
            return `https://ipfs.io/ipfs/${uri.substring(7)}`;
        }
        return uri;
     }

    // ИЗМЕНЕНИЕ: Сброс включает очистку decimals
     function resetBalancesAndTransfer() {
        balancesDiv.innerHTML = 'Нет данных';
        transferStatusDiv.textContent = '';
        currentBalances = {}; // Очищаем полностью
        transferButton.disabled = true;
    }

    // --- ОБНОВЛЕННАЯ Функция получения балансов и метаданных ---
    async function getBalances() {
        // ... (проверки адреса контракта, подключения) ...
        currentContractAddress = contractAddressInput.value.trim();
        if (!ethers.utils.isAddress(currentContractAddress)) { /*...*/ return; }
        if (!provider || !userAddress) { /*...*/ return; }

        logMessage(`Запрос балансов для контракта ${currentContractAddress}...`);
        balancesDiv.innerHTML = '<i>Загрузка балансов...</i>';
        getBalanceButton.disabled = true;
        resetBalancesAndTransfer(); // Сброс перед началом

        try {
            const contract = new ethers.Contract(currentContractAddress, erc1155Abi, provider);
            // ... (формирование idsToCheck, accounts) ...
            const idsToCheck = [];
            const accounts = [];
            for (let i = 0; i <= ID_FETCH_LIMIT; i++) {
                idsToCheck.push(ethers.BigNumber.from(i));
                accounts.push(userAddress);
            }

            logMessage(`Вызов balanceOfBatch для ID 0-${ID_FETCH_LIMIT}...`);
            const balancesBigNum = await contract.balanceOfBatch(accounts, idsToCheck);
            logMessage('Балансы получены. Запрос метаданных...');

            // ... (фильтрация tokensWithBalance) ...
            const tokensWithBalance = [];
            balancesBigNum.forEach((balance, index) => {
                if (!balance.isZero()) {
                    tokensWithBalance.push({ id: idsToCheck[index], balance: balance });
                }
            });

            if (tokensWithBalance.length === 0) { /* ... (обработка случая без балансов) ... */
                 balancesDiv.innerHTML = `Нет токенов с балансом > 0 в диапазоне ID 0-${ID_FETCH_LIMIT}.`;
                 logMessage(`Нет токенов с балансом > 0 в диапазоне ID 0-${ID_FETCH_LIMIT}.`);
                 return;
            }

            balancesDiv.innerHTML = `<i>Загрузка метаданных (${tokensWithBalance.length} токенов)...</i>`;

            // --- Запрос метаданных ---
            const metadataPromises = tokensWithBalance.map(async (token) => {
                const tokenId = token.id;
                const balance = token.balance; // raw BigNumber balance
                let name = `Token ID: ${tokenId.toString()}`;
                let imageUrl = null;
                let decimals = 0; // <-- ИЗМЕНЕНИЕ: Десятичные по умолчанию 0
                let metadataError = null;

                try {
                    const rawUri = await contract.uri(tokenId);
                    const resolvedUri = resolveMetadataUri(rawUri, tokenId);

                    if (resolvedUri) {
                         logMessage(`[ID: ${tokenId}] Запрос метаданных с ${resolvedUri}`);
                         const controller = new AbortController();
                         const timeoutId = setTimeout(() => controller.abort(), METADATA_FETCH_TIMEOUT);

                         try {
                            const response = await fetch(resolvedUri, { signal: controller.signal });
                            clearTimeout(timeoutId);

                            if (!response.ok) throw new Error(`HTTP ${response.status}`);

                            const metadata = await response.json();
                            name = metadata.name || name;
                            imageUrl = metadata.image || metadata.image_url || metadata.imageUrl || null;
                             if (imageUrl && imageUrl.startsWith('ipfs://')) {
                                 imageUrl = `https://ipfs.io/ipfs/${imageUrl.substring(7)}`;
                             }

                            // <-- ИЗМЕНЕНИЕ: Получаем decimals из метаданных
                            if (metadata.decimals !== undefined && Number.isInteger(metadata.decimals) && metadata.decimals >= 0) {
                                decimals = metadata.decimals;
                                logMessage(`[ID: ${tokenId}] Обнаружены decimals: ${decimals}`);
                            } else {
                                 logMessage(`[ID: ${tokenId}] Decimals не найдены или некорректны в метаданных, используется 0.`);
                            }

                            logMessage(`[ID: ${tokenId}] Метаданные получены: Имя='${name}', Decimals=${decimals}`);

                         } catch (fetchError) { /* ... (обработка ошибок fetch) ... */
                             clearTimeout(timeoutId);
                             metadataError = fetchError.message || 'Ошибка сети/CORS/JSON/Таймаут';
                             logMessage(`[ID: ${tokenId}] Ошибка fetch: ${metadataError}`);
                          }
                    } else { /* ... (обработка отсутствия URI) ... */
                         metadataError = 'URI отсутствует/невалиден';
                         logMessage(`[ID: ${tokenId}] URI метаданных отсутствует.`);
                      }
                } catch (error) { /* ... (обработка ошибок contract.uri) ... */
                    metadataError = error.message || 'Ошибка контракта/URI';
                    logMessage(`[ID: ${tokenId}] Ошибка получения URI: ${metadataError}`);
                 }

                // Возвращаем объект с новыми данными
                return {
                    id: tokenId,
                    rawBalance: balance, // Сохраняем сырой баланс
                    name: name,
                    imageUrl: imageUrl,
                    decimals: decimals, // Сохраняем decimals
                    error: metadataError
                };
            });

            const metadataResults = await Promise.allSettled(metadataPromises);

            // --- Отображение результатов ---
            currentBalances = {}; // Очищаем перед заполнением
            const balanceList = document.createElement('ul');
            let displayedCount = 0;

            metadataResults.forEach(result => {
                 if (result.status === 'fulfilled') {
                     const data = result.value;
                     const idStr = data.id.toString();
                     const rawBalanceStr = data.rawBalance.toString();
                     const decimals = data.decimals;

                     // Сохраняем данные для перевода
                     currentBalances[idStr] = {
                         rawBalance: rawBalanceStr,
                         decimals: decimals,
                         name: data.name // Сохраняем имя для возможных сообщений об ошибках
                     };
                     displayedCount++;

                     const listItem = document.createElement('li');

                     // --- Картинка ---
                     const imageDiv = document.createElement('div');
                     imageDiv.classList.add('token-image');
                     if (data.imageUrl) { /* ... (код для img) ... */
                        const img = document.createElement('img');
                        img.src = data.imageUrl;
                        img.alt = data.name;
                        img.onerror = () => { imageDiv.innerHTML = '[Ошибка загр.]'; };
                        imageDiv.appendChild(img);
                     } else { imageDiv.textContent = '[Нет изобр.]'; }

                     // --- Информация о токене ---
                     const infoDiv = document.createElement('div');
                     infoDiv.classList.add('token-info');

                     // <-- ИЗМЕНЕНИЕ: Форматируем баланс с учетом decimals
                     let formattedBalance = '';
                     try {
                         formattedBalance = ethers.utils.formatUnits(data.rawBalance, decimals);
                         // Убираем ненужные .0 для целых чисел после форматирования
                         if (decimals === 0 && formattedBalance.endsWith('.0')) {
                             formattedBalance = formattedBalance.slice(0, -2);
                         } else if (decimals > 0 && formattedBalance.includes('.') && formattedBalance.endsWith('0')) {
                            // Убираем незначащие нули на конце дробной части
                            formattedBalance = parseFloat(formattedBalance).toString();
                         }
                     } catch (formatError) {
                         logMessage(`[ID: ${idStr}] Ошибка форматирования баланса: ${formatError.message}`);
                         formattedBalance = 'Ошибка!'; // Показываем ошибку, если форматнуть не удалось
                     }


                     infoDiv.innerHTML = `
                         <strong>${data.name}</strong>
                         <small>ID: ${idStr}</small>
                         <div class="balance-line">Баланс: <strong>${formattedBalance}</strong></div>
                         <div class="raw-balance-line">Базовых единиц: ${rawBalanceStr}</div>
                         ${data.error ? `<span class="metadata-error">Ошибка метаданных: ${data.error}</span>` : ''}
                     `;

                     // --- Поле для ввода количества ---
                     const transferDiv = document.createElement('div');
                     transferDiv.classList.add('token-transfer');
                     const amountInput = document.createElement('input');
                     amountInput.type = 'number';
                     // amountInput.min = '0'; // Можно убрать min, т.к. валидация в JS
                     // Устанавливаем max в *форматированном* виде для удобства пользователя
                     amountInput.max = formattedBalance;
                     // Устанавливаем step="any" для возможности ввода дробных чисел
                     amountInput.step = 'any';
                     amountInput.placeholder = 'Кол-во';
                     amountInput.dataset.tokenId = idStr;
                     transferDiv.appendChild(amountInput);

                     listItem.appendChild(imageDiv);
                     listItem.appendChild(infoDiv);
                     listItem.appendChild(transferDiv);
                     balanceList.appendChild(listItem);

                 } else { /* ... (обработка rejected промисов) ... */
                    logMessage(`Критическая ошибка обработки промиса метаданных: ${result.reason}`);
                 }
             });

             // ... (обновление DOM и кнопки transferButton) ...
              if (displayedCount > 0) {
                balancesDiv.innerHTML = '';
                balancesDiv.appendChild(balanceList);
                transferButton.disabled = false;
                logMessage(`Отображены балансы и метаданные для ${displayedCount} токенов.`);
             } else {
                 balancesDiv.innerHTML = 'Не удалось получить метаданные ни для одного токена.';
                 logMessage('Не удалось получить метаданные ни для одного токена.');
                 transferButton.disabled = true;
             }

        } catch (error) { /* ... (обработка критических ошибок getBalances) ... */
            logMessage(`Критическая ошибка при получении балансов: ${error.message || error}`);
            balancesDiv.innerHTML = `Ошибка получения балансов: ${error.message || error}`;
            transferButton.disabled = true;
         } finally {
            getBalanceButton.disabled = false;
        }
    }

    // --- ОБНОВЛЕННАЯ Функция перевода токенов ---
    async function transferTokens() {
        const recipientAddress = recipientAddressInput.value.trim();
        if (!ethers.utils.isAddress(recipientAddress)) { /*...*/ return; }
        if (!signer || !userAddress || !currentContractAddress) { /*...*/ return; }

        const idsToTransfer = [];
        const amountsToTransfer = []; // Будет содержать raw BigNumber количества
        let inputError = false;
        let conversionError = false;

        const amountInputs = balancesDiv.querySelectorAll('input[type="number"][data-token-id]');

        amountInputs.forEach(input => {
            const idStr = input.dataset.tokenId;
            const amountStr = input.value.trim(); // Количество, введенное пользователем (может быть дробным)
            input.style.borderColor = ''; // Сброс подсветки

            if (amountStr && parseFloat(amountStr) > 0) {
                const tokenData = currentBalances[idStr]; // Получаем { rawBalance, decimals, name }
                if (!tokenData) {
                    logMessage(`[Transfer Error] Не найдены данные для ID ${idStr} в currentBalances.`);
                    inputError = true; // Критическая ошибка, данных нет
                    input.style.borderColor = 'red';
                    return; // Пропустить этот инпут
                }

                const { rawBalance: rawBalanceStr, decimals } = tokenData;
                const rawBalanceBigNum = ethers.BigNumber.from(rawBalanceStr);

                try {
                    // <-- ИЗМЕНЕНИЕ: Преобразуем введенное значение в raw BigNumber с учетом decimals
                    const rawAmountToSend = ethers.utils.parseUnits(amountStr, decimals);

                    // Валидация
                    if (rawAmountToSend.isNegative() || rawAmountToSend.isZero()) {
                         throw new Error("Количество должно быть положительным.");
                    }
                    if (rawAmountToSend.gt(rawBalanceBigNum)) {
                        throw new Error(`Превышает баланс (${ethers.utils.formatUnits(rawBalanceBigNum, decimals)})`);
                    }

                    // Если все проверки пройдены
                    idsToTransfer.push(idStr);
                    amountsToTransfer.push(rawAmountToSend); // Добавляем raw BigNumber

                } catch (e) {
                    // Ошибка парсинга (parseUnits) или валидации
                    logMessage(`[ID: ${idStr}] Ошибка ввода/валидации: ${e.message} (Введено: "${amountStr}")`);
                    input.style.borderColor = 'red';
                    inputError = true;
                    if (e.message.includes('underflow') || e.message.includes('invalid decimal value')) {
                        conversionError = true; // Ставим флаг, если проблема с конвертацией
                    }
                }
            } else if (amountStr && parseFloat(amountStr) <= 0) {
                // Если явно введен 0 или отрицательное
                 input.style.borderColor = 'red';
                 logMessage(`[ID: ${idStr}] Количество должно быть положительным.`);
                 inputError = true;
            }
        });

        if (inputError) {
            let alertMessage = 'Пожалуйста, исправьте ошибки в полях количества (отмечены красным).';
            if (conversionError) {
                 alertMessage += '\nУбедитесь, что количество десятичных знаков не превышает допустимое для токена.';
            }
            alert(alertMessage);
            return;
        }

        if (idsToTransfer.length === 0) { /* ... (обработка случая без токенов для перевода) ... */
            logMessage('Нет токенов для перевода.');
            alert('Пожалуйста, укажите количество > 0 хотя бы для одного токена.');
            return;
        }

        // ... (Логирование перед отправкой, показ статуса) ...
        logMessage(`Подготовка к переводу ${idsToTransfer.length} типов токенов на адрес ${recipientAddress}...`);
        logMessage(`IDs: [${idsToTransfer.join(', ')}]`);
        // Логируем raw amounts, которые пойдут в транзакцию
        logMessage(`Raw Amounts: [${amountsToTransfer.map(a => a.toString()).join(', ')}]`);
        transferButton.disabled = true;
        transferStatusDiv.textContent = 'Подтвердите транзакцию в MetaMask...';

        try {
            const contract = new ethers.Contract(currentContractAddress, erc1155Abi, signer);
            // Отправляем ids (строки) и raw amounts (BigNumber)
            const tx = await contract.safeBatchTransferFrom(
                userAddress, recipientAddress, idsToTransfer, amountsToTransfer, '0x'
            );
            // ... (Ожидание транзакции, обновление статуса, обновление балансов) ...
             logMessage(`Транзакция отправлена! Хэш: ${tx.hash}`);
             transferStatusDiv.textContent = `Транзакция отправлена! Ожидание подтверждения...`;
             const receipt = await tx.wait();
             logMessage(`Транзакция подтверждена! Блок: ${receipt.blockNumber}`);
             transferStatusDiv.innerHTML = `Успешно! <a href="${POLYGON_EXPLORER}tx/${tx.hash}" target="_blank">PolygonScan</a>`;
             amountInputs.forEach(input => input.value = ''); // Очистка инпутов
             logMessage('Обновление балансов после перевода...');
             await getBalances(); // Перезапрос балансов и метаданных

        } catch (error) { /* ... (обработка ошибок транзакции) ... */
             logMessage(`Ошибка перевода: ${error.message || error}`);
             transferStatusDiv.textContent = `Ошибка перевода: ${error.message || error}`;
             // Разблокируем кнопку, если после ошибки все еще есть балансы
             transferButton.disabled = Object.keys(currentBalances).length === 0;
        }
    }

    // --- Инициализация (без изменений) ---
     window.addEventListener('load', () => {
        logMessage('Страница загружена. Ожидание подключения кошелька.');
        connectButton.addEventListener('click', connectWallet);
        getBalanceButton.addEventListener('click', getBalances);
        transferButton.addEventListener('click', transferTokens);
     });

</script>

</body>
</html>